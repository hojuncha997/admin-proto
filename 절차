1. 레이아웃 제작(사이드바, 네비게이션, 본문 등 큰 레이아웃)

2. 로그인 페이지(/sections/auth/login.js) 생성

3. 라우팅 설정 : routes디렉토리(paths.js, elements.js, index.js, useRoutes, BrowseRouter, Navigate, useNavigation)
- npm install react-router-dom
- routes/index.js에서 useRoutes로 Router함수를 설정하고 export.
- 이 <Router>함수를 App.js에서 import하고 return 하여 프로젝트 전체에서 라우팅 가능토록 설정
- App.js을 <BrowserRouter>로 감싸서 프로젝트 전체에서 라우팅 설정.(여기서는 index.js를 감쌌음.)
- App이 직접적인 컴포넌트를 반환하지는 않지만, Router함수에 따라 "/"경로에 지정된 <Login> 컴포넌트가 반환된다.
- 로그인에 성공하면 useNavigate를 사용하여 "/dashboard" 경로로 이동한다. 
- "/dashboard"는 useRoutes에 지정된 경로에 따라 <DashboardLayout />를 반환한다.
- <DashboardLayout />에는 상단 네비게이션인 <UpperNav>, 좌측에 존재하는 <SideBar>, 메뉴에 따라 본문이 보여질 <MainContainer> 컴포넌트가 존재한다.
- 이 중 <MainContainer>는 <Outlet> 컴포넌트를 감싸고 있다. <Outlet>은 useRoutes에 지정한 경로에 따라, "/dashboard"의 하위 경로의 컴포넌트들을 동적으로 보여준다.
- 처음에는 useRoutes에서 "/dashboard" 경로의 children 중 path가 설정되지 않은 <DashboardHome>이 자동으로 보여진다.



4. 인증관련 세션 및 전체 상태를 관리하기 위한 auth설정(JwtContext.js, useAuthContext.js)
    여기서는 axios, 초기화, 인증여부를 검증해야 한다. 그리고 axios를 사용하여 서버에서 토큰을 받고 그걸로 초기화 및 인증완료 여부를 상태로 만들어 준 뒤,
    그걸 createContext를 사용하여 컨텍스트에 저장한 뒤, useContext를 사용하여 AuthContext로 만든 뒤 이를 다른 곳에서 임포트하여 프로젝트 전반에서 사용한다. 

- 서버와의 통신 후 세션을 설정해야 하므로 axios를 다운받고 인스턴스를 만들고 함수를 가져다 쓴다. /src/utils 디렉토리 만들고 axios.js 생성
- axios.js에서는 일반적으로 통신에 사용할 axios.create()사용하여 axisInstance를 만들고 요청인터셉터와 응답 인터셉터를 작성한다.
- 또한 파일 전송에 대비하여 fileInstance도 생성한다. 이 녀석들 JwtContext.js등 서버 통신이 필요한 곳에서 가져다 쓰는 것이다.
- 참고로 axios.js에서 만든 함수들은 서버 주소가 필요한데, 이건 .env 파일에 작성한 상수를 /src/config-global.js에서 상수로 저장하고 다시 axios.js에서 가져다 쓰는 것이다.

- src/utils/localStorageAvailable.js도 만들어준다. 여기에는 localStorage에 item을 set, remove할 수 있는 함수를 작성한다. 
- localStorageAvailable도 JwtContext에 임포트해준다.

- /src/auth 디렉토리에 utils.js도 만든다. 이 파일은 인증/세션과 관련된 함수들이 작성되어 있다. 이 함수들을 JwtContext에 임포트하여 사용한다.
- 임포트 하는 것은 setSession과 isValidToken이지만, tokenExpired역시 중요하다.
- tokenExpired 함수는  setTimeout 함수를 사용하여 토큰의 만료시간을 측정하고, 만료되면 로그아웃 시키는 로직이 이 안에 들어있기 때문이다.


#
- 이제 본격적으로 src/auth/JwtContext를 작성한다. src/utils/axios와 src/auth/utils.js를 임포트 해주면, 초기 상태값을 만들어준다.
- 이 초기값은 useReducer훅의 두 번째 파라미터로 들어간다. 두 번째로는 리듀서로 사용할 reducer함수를 작성해준다. 이 함수는 useReducer함수의 첫 번째 함수로 들어간다.
- useReducer는 기본적으로 이 상태값을 reducer함수에 전달하며, dispatch를 호출하여 값을 바꿀 때마다 리듀서 함수에 전달하여 상태값을 변경하도록 만든다.

- 두 번째로는 컨텍스트를 만든다. createContext 함수를 사용하여 기본값이 null인 함수를 만든다. AuthContext.Provider의 value속성을 통해 값을 바꿔줄 것이다.

- 세 번째로는 AuthProvider 함수를 만든다. 이 함수 내에서 useReducer 함수를 생성한다.
    const [state, dispatch] = useReducer(reducer, initialState);
  이렇게 넣어준다. 여기에는 아래와 같은 함수들이 작성돼 있다.
  
    -- Initialize: 초기화 함수. 토큰값 존재/유효 여부를 확인하여 그 결과를 dispatch함수에 action으로 담아 초기 상태값을 바꾼다.
    -- login: API 통신을 통해 확인하여 그 결과를 dispatch함수를 사용하여 action을 전달하고 상태값을 변경시킨다.
        또한 서버로부터 획득한 토큰을 setSession에 넣어 토큰을 localStorage에 넣고, axios 기본설정을 하며, 백그라운드에서 토큰 만료시간을 계속 확인하도록 한다.
    -- register: API에게 가입 정보를 넣어 날리고, dispatch 호출하여 상태를 바꾼다.(이건 수정 필요)
    -- logout: setSession(null) 하여 세션과 토큰을 날려버리고 dispatch를 하여 인가 상태를 바꿔버린다.

    -- memoizedValue: useMemo 훅을 사용한 함수로서, 캐쉬할 정보를 담는다. 최종 상태값들과 함수, 임의로 넣은 값들이 들어 있으며,
        추후 useAuthContext를 통해 쉽게 꺼내서 사용할 수 있도록 만든 것이다.

이 AuthProvider 함수가 최종적으로 리턴하는 것은 아래의 형태이다.

  return (
    <AuthContext.Provider value={memoizedValue}>
      {children}
    </AuthContext.Provider>
  );

AuthContext.Provider 컴포넌트의 value 속성을 사용해 memoizedValue를 넣어준다.
그렇게 하면 이 컴포넌트로 감싼 하위 컴포넌트들은 쉽게 memoizedValue의 값을 꺼내어 사용할 수 있다.
이렇게 되기 위해선느 App.js를 AuthContext.Provider로 감싸거나, App.js의 반환값을 AuthContext.Provider로 감싸야 한다.
여기서는 가장 바깥에 AuthContext.Provider야 한다.
하지만 우리는 이 값을 AuthProvider 함수로 감쌌으므로 아래와 같이 해주었다.

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <GlobalStyle />
        <Router />
      </BrowserRouter>
    </AuthProvider>
  );
}

이제 App아래의 전역에서 memoizedValue를 사용할 수 있다.

그리고 useAuthContext를 만들어 주었다. 이 커스텀 훅에서는 아래와 같이 useContext를 사용한다.
  const context = useContext(AuthContext);
그리고 context를 반환한다. 따라서 다른 컴포넌트에서 consumer를 사요하지 않고도 보다 쉬운 방법으로 context를 가져다 쓸 수 있으며,
context의 내용이 바뀌더라도, 즉 firebaseContext가 되더라도 적용만 하면 되므로 객체지향적으로 사용할 수 있다.

src/sections/auth/Login.js 컴포넌트에서는 

import { useAuthContext } from "../../auth/useAuthContext";
...
  const { login, isAuthenticated, isInitialized } = useAuthContext();
이런 식으로 전역 값과 함수를 가져다 쓸 수 있었다.


- src/auth/GuestGuard.js와 src/auth/AuthGuard.js를 추가한다. src/routes/elements.js에서 이 둘을 임포트해서 익스포트 한다.
src/routes/index에서는 이 둘을 임포트한다. <GuestGuard>로는 login경로를 감싸고, <AuthGuard>로는 dashboard경로를 감싼다.

export default function Router() {
  return useRoutes([
    // Auth
    {
      path: "/",
      element: <Navigate to="/login" replace />,
      // element: <div>메인("/")</div>,
    },
    {
      path: "login",
      element: (
        <GuestGuard>
          <Login />,
        </GuestGuard>
      ),
    },
    {
      path: "dashboard",
      element: (
        <AuthGuard>
          <DashboardLayout />
        </AuthGuard>
      ),
      children: [

GuestGuard는 isAuthenticated가 true이면 PATH_DASHBOARD.root 즉, /dashboard로 리다이렉트 시킨다. 만약 isInitialized가 false라면 로딩 중임을 보여준다.

AuthGuard는 isInitialized가 false이면 로딩 중 화면을 표시한다.
  - isAuthenticated가 false일 때, 요청한 경로(requestedLocation)와 pathname이 다르면 setRequestedLocation(pathname)하고 로그인 화면을 반환한다. 이 때 주소창은 변하지 않는다.
  - 로그인에 성공하면,  requestedLocation이 null이 아닌 동시에,  pathname이 requestedLocation과 다른 경우 requestedLocation경로로 사용자를 이동시킨다. 그리고 setRequestedLocation(null)하여 초기화 한다.

만약 requestedLocation이 존재하지 않는다면 <AuthGuard>의 자식 컴포넌트인 <DashboardLayou>으로 이동시킨다.

즉,

GuestGuard -> Login -> 로그인 성공 -> GuestGuard에서 PATH_DASHBOARD.root로 리다이렉트 ->
-> AuthGuard 만남 -> 초기화 및 인증 검사 -> 통과 -> 자식 컴포넌트인 대시보드로 이동

인증이 필요한 페이지로 직접 요청 -> AuthGuard에서 초기화 및 인증 검사 -> 초기화는 성공했으나 인증이 실패한 경우 -> 해당 요청 path를 저장하고 로그인 화면 반환(이 때 주소창 변경없음) -> 로그인 성공 -> 전역 상태 변경 ->
-> isInitialized가 true, isAuthenticated가 true인 경우 




